[
  {
    "id": 1,
    "title": "twoSum.js",
    "language": "js",
    "blocks": [
      "var twoSum = function(nums, target) {\n",
      "    let map = new Map();",
      "\n",
      "    for (let i = 0; i < nums.length; i++) {\n",
      "        let complement = target - nums[i];\n",
      "\n",
      "        if (map.has(complement)) {\n",
      "            return [map.get(complement), i];\n",
      "        }\n",
      "\n",
      "        map.set(nums[i], i);\n",
      "    }\n",
      "\n",
      "    return [];\n",
      "};\n"
    ]
  },
  {
    "id": 2,
    "title": "LongestSubstring.js",
    "language": "js",
    "blocks": [
      "function lengthOfLongestSubstring(s) {\n",
      "    let charIndexMap = new Map();\n",
      "    let maxLen = 0;\n",
      "    let start = 0; /\n",
      "\n",
      "    for (let end = 0; end < s.length; end++) { \n",
      "        if (charIndexMap.has(s[end]) && charIndexMap.get(s[end]) >= start) {\n",
      "            start = charIndexMap.get(s[end]) + 1;\n",
      "        }\n",
      "\n",
      "        charIndexMap.set(s[end], end)\n",
      "\n",
      "        maxLen = Math.max(maxLen, end - start + 1);\n",
      "    }\n",
      "\n",
      "    return maxLen;\n",
      "};\n"
    ]
  },
  {
    "id": 3,
    "title": "MedianSortedArrays.js",
    "language": "js",
    "blocks": [
      "function findMedianSortedArrays(nums1, nums2) {\n",
      "    if (nums1.length > nums2.length) {\n",
      "        [nums1, nums2] = [nums2, nums1];\n",
      "    }\n",
      "\n",
      "    const m = nums1.length;\n",
      "    const n = nums2.length;\n",
      "    let left = 0;\n",
      "    let right = m;\n",
      "\n",
      "    while (left <= right) {\n",
      "        const partition1 = Math.floor((left + right) / 2);\n",
      "        const partition2 = Math.floor((m + n + 1) / 2) - partition1;\n",
      "\n",
      "        const maxLeft1 = partition1 === 0 ? -Infinity : nums1[partition1 - 1];\n",
      "        const minRight1 = partition1 === m ? Infinity : nums1[partition1];\n",
      "\n",
      "        const maxLeft2 = partition2 === 0 ? -Infinity : nums2[partition2 - 1];\n",
      "        const minRight2 = partition2 === n ? Infinity : nums2[partition2];\n",
      "\n",
      "        if (maxLeft1 <= minRight2 && maxLeft2 <= minRight1) {\n",
      "            if ((m + n) % 2 === 0) {\n",
      "                return (Math.max(maxLeft1, maxLeft2) + Math.min(minRight1, minRight2)) / 2;\n",
      "            } else {\n",
      "                return Math.max(maxLeft1, maxLeft2);\n",
      "            }\n",
      "        } else if (maxLeft1 > minRight2) {\n",
      "            right = partition1 - 1;\n",
      "        } else {\n",
      "            left = partition1 + 1;\n",
      "        }\n",
      "    }\n",
      "}\n"
    ]
  },

  {
    "id": 4,
    "title": "longestPalindrome.js",
    "language": "js",
    "blocks": [
      "function longestPalindrome(s) {\n",
      "    if (s.length === 0) return  \"\";\n",
      "\n",
      "    function expandAroundCenter(left, right) {\n",
      "        while (left >= 0 && right < s.length && s[left] === s[right]) {\n",
      "            left--;\n",
      "            right++;\n",
      "        }\n",
      "        return s.slice(left + 1, right);\n",
      "    }\n",
      "\n",
      "    let longest =  \"\";\n",
      "    for (let i = 0; i < s.length; i++) {\n",
      "        let palindrome1 = expandAroundCenter(i, i);\n",
      "        if (palindrome1.length > longest.length) {\n",
      "            longest = palindrome1;\n",
      "        }\n",
      "        let palindrome2 = expandAroundCenter(i, i + 1);\n",
      "        if (palindrome2.length > longest.length) {\n",
      "            longest = palindrome2;\n",
      "        }\n",
      "    }\n",
      "\n",
      "    return longest;\n",
      "\n"
    ]
  },

  {
    "id": 5,
    "title": "getPermutations.js",
    "language": "js",
    "blocks": [
      "function getPermutations(str) {\n",
      "    if (str.length === 0) return [''];\n",
      "    const permutations = [];\n",
      "    const firstChar = str[0];\n",
      "    const rest = str.slice(1);\n",
      "    const words = getPermutations(rest);\n",
      "    for (let word of words) {\n",
      "        for (let i = 0; i <= word.length; i++) {\n",
      "            const newWord = word.slice(0, i) + firstChar + word.slice(i);\n",
      "            permutations.push(newWord);\n",
      "        }\n",
      "    }\n",
      "    return permutations;\n",
      "}\n"
    ]
  },

  {
    "id": 6,
    "title": "sortedMerge.js",
    "language": "js",
    "blocks": [
      "function sortedMerge(A, B) {\n",
      "    let indexA = A.length - 1;\n",
      "    let indexB = B.length - 1;\n",
      "    let indexMerged = A.length + B.length - 1;\n",
      "    A.length = A.length + B.length;\n",
      "    while (indexB >= 0) {\n",
      "        if (indexA >= 0 && A[indexA] > B[indexB]) {\n",
      "            A[indexMerged--] = A[indexA--];\n",
      "        } else {\n",
      "            A[indexMerged--] = B[indexB--];\n",
      "        }\n",
      "    }\n",
      "}\n"
    ]
  },
  {
    "id": 7,
    "title": "maxArea.js",
    "language": "js",
    "blocks": [
      "function maxArea(height) {\n",
      "    let left = 0;\n",
      "    let right = height.length - 1;\n",
      "    let maxArea = 0;\n",
      "\n",
      "    while (left < right) {\n",
      "        const width = right - left;\n",
      "        const minHeight = Math.min(height[left], height[right]);\n",
      "        const area = width * minHeight;\n",
      "\n",
      "        maxArea = Math.max(maxArea, area);\n",
      "\n",
      "        if (height[left] < height[right]) {\n",
      "            left++;\n",
      "        } else {\n",
      "            right--;\n",
      "        }\n",
      "    }\n",
      "\n",
      "    return maxArea;\n",
      "\n"
    ]
  }

]
