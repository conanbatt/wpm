[
  {
    "id": 1,
    "title": "twoSum.js",
    "language": "js",
    "blocks": [
      "var twoSum = function(nums, target) {\n",
      "    let map = new Map();",
      "\n",
      "    for (let i = 0; i < nums.length; i++) {\n",
      "        let complement = target - nums[i];\n",
      "\n",
      "        if (map.has(complement)) {\n",
      "            return [map.get(complement), i];\n",
      "        }\n",
      "\n",
      "        map.set(nums[i], i);\n",
      "    }\n",
      "\n",
      "    return [];\n",
      "};\n"
    ]
  },
  {
    "id": 2,
    "title": "Palindrome Number.js",
    "language": "js",
    "blocks": [
      "var isPalindrome = function(x) {\n",
      "\n",
      "    let reversed = 0, original = x;\n",
      "    while (original > reversed) {\n",
      "        reversed = reversed * 10 + original % 10;\n",
      "        original = Math.floor(original / 10);\n",
      "    }\n",
      "\n",
      "    let exactMatch = original === reversed;\n",
      "    let ignoreMiddle = original === Math.floor(reversed / 10);\n",
      "    return exactMatch || ignoreMiddle;\n",
      "};\n"
    ]
  },
  {
    "id": 3,
    "title": "Roman to Integer.js",
    "language": "js",
    "blocks": [
      "var romanToInt = function(s) {\n",
      "        'I': 1, 'V': 5, 'X': 10, 'L': 50,\n",
      "        'C': 100, 'D': 500, 'M': 1000\n",
      "    }\n",
      "\n",
      "    for (let i = 0; i < s.length; i++) {\n",
      "        let current = romanMap[s[i]];\n",
      "        let next = romanMap[s[i + 1]];\n",
      "\n",
      "        if (next > current) {\n",
      "            total += (next - current);\n",
      "            i++;\n",
      "        } else {\n",
      "            total += current;\n",
      "        }\n",
      "    }\n",
      "\n",
      "    return total;\n",
      "};\n"
    ]
  },

  {
    "id": 4,
    "title": "insertion",
    "language": "js",
    "blocks": [
      "function insertion(N, M, i, j) {\n",
      "    const allOnes = ~0;\n",
      "    const left = allOnes << (j + 1);\n",
      "    const right = (1 << i) - 1;\n",
      "    const mask = left | right;\n",
      "    const nCleared = N & mask;\n",
      "    const mShifted = M << i;\n",
      "    return nCleared | mShifted;\n",
      "        this.sizes[stackNum]++;\n",
      "        this.sizes[stackNum]++;\n",
      "}\n"
    ]
  },

  {
    "id": 5,
    "title": "getPermutations",
    "language": "js",
    "blocks": [
      "function getPermutations(str) {\n",
      "    if (str.length === 0) return [''];\n",
      "    const permutations = [];\n",
      "    const firstChar = str[0];\n",
      "    const rest = str.slice(1);\n",
      "    const words = getPermutations(rest);\n",
      "    for (let word of words) {\n",
      "        for (let i = 0; i <= word.length; i++) {\n",
      "            const newWord = word.slice(0, i) + firstChar + word.slice(i);\n",
      "            permutations.push(newWord);\n",
      "        }\n",
      "    }\n",
      "    return permutations;\n",
      "}\n"
    ]
  },

  {
    "id": 6,
    "title": "sortedMerge",
    "language": "js",
    "blocks": [
      "function sortedMerge(A, B) {\n",
      "    let indexA = A.length - 1;\n",
      "    let indexB = B.length - 1;\n",
      "    let indexMerged = A.length + B.length - 1;\n",
      "    A.length = A.length + B.length;\n",
      "    while (indexB >= 0) {\n",
      "        if (indexA >= 0 && A[indexA] > B[indexB]) {\n",
      "            A[indexMerged--] = A[indexA--];\n",
      "        } else {\n",
      "            A[indexMerged--] = B[indexB--];\n",
      "        }\n",
      "    }\n",
      "}\n"
    ]
  },
  {
    "id": 7,
    "title": "getPermutations",
    "language": "js",
    "blocks": [
      "    const n = matrix.length;\n",
      "    for (let layer = 0; layer < Math.floor(n / 2); layer++) {\n",
      "        const first = layer;\n",
      "        const last = n - 1 - layer;\n",
      "        for (let i = first; i < last; i++) {\n",
      "            const offset = i - first;\n",
      "            const top = matrix[first][i];\n",
      "            matrix[first][i] = matrix[last - offset][first];\n",
      "            matrix[last - offset][first] = matrix[last][last - offset];\n",
      "            matrix[last][last - offset] = matrix[i][last];\n",
      "            matrix[i][last] = top;\n",
      "        }\n",
      "    }\n",
      "    return matrix;\n",
           "}\n"
    ]
  }

]
